<!-- Introduction to react -->
<!-- advantages of react -->

<!-- React is a popular JavaScript library for building user interfaces, primarily developed and maintained by Facebook (now Meta).
  It allows developers to create reusable UI components and manage the state efficiently. 
  React follows a component-based architecture and uses a virtual DOM for optimized rendering.

  react (javascript librarey)
  it uses virtual dom technology
  and components based artictecture

  html , css and js 

Advantages of React
Component-Based Architecture – Breaks UI into reusable components for better maintainability.
Virtual DOM – Improves performance by updating only changed parts of the UI.
One-Way Data Binding – Ensures predictable data flow, making debugging easier.
Reusable Components – Saves time by using pre-built components across the application.
Strong Community Support – Backed by Meta and a large developer community.
SEO-Friendly – Faster rendering improves SEO compared to traditional JavaScript frameworks.
Easy to Learn – Uses JSX, which is similar to HTML, making it accessible for beginners.
Rich Ecosystem – Supports state management libraries like Redux, Context API, and integrations with various tools. -->

<!-- Difference Between Virtual DOM and Real DOM
Feature	Virtual DOM	Real DOM
Definition	A lightweight copy of the real DOM that React uses to improve performance.	The actual structure of HTML elements rendered in the browser.
Update Speed	Faster because it updates only the changed parts.	Slower because it updates the entire UI.
Efficiency	Uses diffing algorithm to find changes and update only necessary parts.	Updates all elements even if only one part of the UI changes.
Performance	High performance due to minimal direct manipulation of the DOM.	Slower performance as changes directly affect the UI.
Re-rendering	Updates only the components that have changed.	Redraws the entire UI for any change.
Memory Usage	Efficient, as React keeps a lightweight virtual representation.	Can consume more memory and processing power. -->

<!-- installation of react  / node js -->
<!-- how to setup basic raeact project -->

<!-- what is markup -->
<!-- jsx (html and js) -->

<!-- markup (html + js ) -->

<!-- html  ====> index.html 

js ====> index.js -->

(js + html ) ====> app.jsx

<!-- react basics -->

<!-- functional component / class component -->

<!-- When to Use Functional vs. Class Components?
✅ Use Functional Components (Recommended):

When writing new React applications.
If you need state or side effects, use Hooks.
When you want cleaner, more modern, and maintainable code.
❌ Use Class Components (Only if required):

When working with older React projects.
If you need to use lifecycle methods without refactoring to Hooks. -->
<!-- how react is rendering the ui  -->
<!-- what is props , how to pass that -->
<!-- props (short for properties) are used to pass data from a parent component to a child component in React. 
 They are read-only and cannot be modified inside the child component. -->

<!-- state management ans what is state -->

<!-- State is a built-in object in React that stores data within a 
 component and causes re-renders when updated. -->

<!-- react rerender , state variable changes , props from pareent is changed, when parent is rerendered! -->

<!-- handling events in react -->

<!-- Event Type	Example -->
<!-- Click	<button onClick={handleClick}>Click</button>
Form Submit	<form onSubmit={handleSubmit}>...</form>
Input Change	<input onChange={handleChange} />
Mouse Hover	<div onMouseEnter={handleHover}>Hover</div>
Key Press	<input onKeyDown={handleKeyPress} />
Prevent Default	event.preventDefault()
Stop Propagation	event.stopPropagation() -->

<!-- condinal operation -->
<!-- 
Your components will often need to display different things depending on
different conditions. In React, you can conditionally render JSX using
JavaScript syntax like if statements, &&, and ? : operators. -->

<!-- how to work with map() -->

<!-- what are keys in list -->
<!-- Keys tell React which array item each component corresponds to, so that it can
match them up later. This becomes important if your array items can move (e.g.
due to sorting), get inserted, or get deleted. A well-chosen key helps React
infer what exactly has happened, and make the correct updates to the DOM tree. -->

<!-- pure/impure components, why we need that -->

<!-- pure: doesnt modify external variable / object,for the same input same output  -->

<!-- every react compoent should be build pure , so that we can use it any where and make it resulable -->

<!-- controlled and un controlled components -->

<!-- A controlled component is a component where React controls
  the form element’s value using useState. -->

<!-- An uncontrolled component lets the DOM handle the form element’s 
   state using useRef instead of useState. -->

<!-- props drilling -->

<!-- context api (global state managemnt) -->

<!-- Problems with Props Drilling , Solutions to Avoid Props Drilling -->
<!-- If the data is only passed down one or two levels, props drilling is fine. But
if multiple levels are involved, Context API or state management solutions are
better. -->

<!-- react router -->

<!-- React Router is a library for handling navigation in React applications. It
enables you to define multiple pages/views and switch between them without a
full page reload. -->

<!-- useNavigate() -->
<!-- link -->
<!-- browerRouter , routes , route  path and element -->

<!-- what are protected routes -->
<!-- You can protect routes using authentication checks. -->
<!-- import { Navigate } from "react-router-dom";

function PrivateRoute({ children }) {
  const isAuthenticated = false; // Change based on authentication logic
  return isAuthenticated ? children : <Navigate to="/" />;
}

 Usage in Routes
<Route path="/profile" element={<PrivateRoute><Profile /></PrivateRoute>} />
 -->

<!-- how to take uper input and play with forms -->
<!-- useState controlled  -->
<!-- useRef  uncontrolled -->
<!-- how to set routes/naviagtion -->
<!-- dynamic routing and url parameter -->

<!-- need revision -->

<!-- types of react hook -->
<!-- what are hooks -->
<!-- Hooks are built-in functions in React that let you use state and lifecycle features in functional components. -->
<!-- useState() : The useState hook allows components to store and update state.-->
<!-- useEffect() : The useEffect hook runs side effects in a component (like fetching data, subscriptions, or DOM manipulation). -->
<!-- useRef() : The useRef hook allows us to access DOM elements and store mutable values without re-rendering.-->
<!-- useMemo() : The useMemo hook caches expensive computations to avoid unnecessary recalculations. -->
<!-- useCallback() : The useCallback hook caches functions so they don’t get recreated on every render.-->

<!-- useState()	Manage component state
useEffect()	Run side effects (API calls, DOM updates)
useRef()	Access DOM elements, store mutable values
useMemo()	Optimize expensive calculations -->
<!-- useCallback()	Cache functions to avoid re-creation -->

<!-- useEffect() -->
<!-- case 1 :  Running on Every Render (No Dependency) -->
<!-- case 2 : Running Only on Mount ([empty] Dependency) -->
<!-- case 3 : Running When a State or Prop Changes,If a dependency 
([count]) is passed, the effect runs only when that state/prop changes. -->

<!-- useEffect(() => {
  Side effect code (e.g., API call, DOM update)
  return () => {
  Cleanup function (optional)
  };
}, [dependencies]); -->

<!-- useMemo() hook -->
<!-- The useMemo hook optimizes performance by 
 memoizing (caching) expensive calculations so they don’t re-run unnecessarily. -->

<!-- const memoizedValue = useMemo(() => computeExpensiveValue(dependency), [dependency]); -->
<!-- 
✅ Avoids unnecessary re-calculations
✅ Improves performance in large lists or expensive operations
✅ Helps prevent unnecessary re-renders -->

<!-- 🎯 When to Use useMemo()?
✅ Expensive computations (e.g., filtering, sorting large lists)
✅ Optimizing re-renders (especially in slow UI updates)
✅ Avoiding unnecessary calculations when unrelated state updates

❌ When NOT to Use useMemo()?
🚫 For simple calculations that don’t impact performance
🚫 If re-rendering is already fast
🚫 Overuse can lead to unnecessary complexity -->

<!-- 
🔹 useMemo() caches expensive computations and only recalculates them when dependencies change.
🔹 It improves performance by preventing unnecessary re-renders.
🔹 Use it wisely in scenarios where computations significantly slow down rendering -->

<!-- useCallback() hook  -->
<!-- The useCallback() hook is used to memoize functions, preventing them from being re-created on every render. It improves performance
  by ensuring that a function reference remains the same unless its dependencies change. -->

<!-- const memoizedFunction = useCallback(() => {
   Function logic
}, [dependencies]);
 -->

<!-- 
🎯 When Should You Use useCallback()?
✅ Passing functions as props to memoized components (React.memo)
✅ Avoiding unnecessary re-creations of event handlers in performance-critical apps
✅ Optimizing re-renders when dealing with child components

-->

<!-- useCallback() vs. useMemo()

   Hook          	Purpose	Returns	Use Case

useMemo()	          Memoizes values	A computed value	
                    Caching expensive calculations


useCallback()	      Memoizes functions	A function	
                    Avoiding unnecessary function re-creations -->

<!-- state magaement teqniqw -->

<!-- 
✅ If your state is local → Use useState
✅ If you need global state → Use Context API
✅ If you need scalability & performance → Use Redux or Zustand
✅ If you want React-friendly state management → Use Recoil -->

<!-- life cycle methods -->

<!-- life cycle methods are avaliable when we are working on class based components !  -->
<!-- as we are working on functional based components, so we can mimic behaviour of lifecycle methods using a hook 
  useEffect() -->

<!-- In React, lifecycle methods are special functions that execute at different phases of a component's life cycle. These methods apply only to class components, but their behavior can be mimicked in functional components using hooks like useEffect(). -->
<!-- 1 : componentDidMount() 
2 : compoentDidUpdate() 
3 : componentWillUnmount() 

<!-- functional lcm / class life cycle menthod-->

<!--
1 : useEffect 1st type : Running on Every Render (No Dependency) 
Runs after the component is inserted into the DOM. Used for API calls,
 event listeners, etc.


2 : useEffect 2st type : Running Only on Mount ([with] Dependency)
Runs after the component updates. Used for API calls, updating the DOM.



3 : useEffect 3st type : Running the return statement/clean up
Runs just before the component is removed. Used for cleanup 
(e.g., remove event listeners). -->

<!-- Fetching / manageming apies in react -->

<!-- Fetching & Managing APIs in React 🚀 In React, API calls are commonly made using
fetch() or libraries like axios. These calls typically occur inside lifecycle
methods (class components) or React hooks (functional components). -->

<!-- Since functional components don’t have lifecycle methods, 
 we use the useEffect() hook to fetch data. -->

<!-- 
 Why useEffect()?
Replaces componentDidMount() for fetching data.
Runs only once ([] dependency array) to avoid unnecessary re-fetching.
Cleans up if needed (like removing event listeners). -->

<!-- Fetch api , axios for http request use effect()-->
<!-- Why Use Axios?
Simplifies API calls (no need for response.json()).
Better error handling with catch().
Automatically parses JSON responses.
 -->

<!-- 
✅ fetch() vs axios → Axios is simpler but requires installation.
✅ useEffect() for API calls → Ensures side effects like fetching data run properly.
✅ Handle loading & errors → Improve UX.
✅ Cancel API calls to prevent memory leaks using AbortController. -->

<!-- handle errors -->

<!-- Error handling in React is essential for better user experience and debugging 
 issues efficiently. Below are different ways to handle errors in React applications. -->
<!-- display ui using apis -->
<!-- 
 📌 Summary: Best Practices
Error Type	                  Solution Example
API Errors	                  try...catch inside useEffect()
Event Handler Errors         	try...catch in event functions
Route Not Found	Route         path="*" for 404 pages -->

<!-- lazyloading concept -->

<!-- Lazy Loading in React
In React, Lazy loading is a technique that allows you to load components,
 modules, or assets asynchronously, improving the loading time of your application.
 It can be achieved by using the built-in React.lazy() method and Suspense component. -->

<!-- Implement Lazy Loding with React.Lazy method

const MyComponent = React.lazy(() => import('./MyComponent')); -->

<!-- <Suspense fallback={<div>Loading...</div>}>
  <MyComponent />
</Suspense> -->

<!-- React Suspense provides better feedback to the user and improves the user experience 
 as a user is not facing any blank screen or space while the content is being loaded.  -->

<!-- React Suspense is designed to handle the loading of the components that make asynchronous API requests. React Suspense can be used by wrapping the <Suspense> 
  component and specifying the fallback content displayed while the component or data is loading.  -->

<!-- Code-splitting: It is an effective technique for optimizing the performance and
efficiency of web applications, especially those with large code bases. By
reducing the amount of code that needs to be loaded when a page first loads,
code splitting can improve the user experience and make your application more
responsive and fast. -->

<!-- Advantages
Lazy loading allows you to use server resources more efficiently by loading only the resources you need. This is very important for high-traffic applications or when server resources are tight. 
A quicker initial load time can be achieved by using lazy loading, which minimizes the amount of code that must be downloaded and parsed when the page first loads. This can speed up your application’s first load time greatly.        -->

<!-- Conclusion React Lazy Loading is a powerful technique that significantly
improves the performance of web applications built with React. One of the key
benefits of lazy loading is that it can help improve the Time to Interactive
(TTI) metric, which is the time it takes for a page to become interactive and
responsive. By delaying the loading of non-critical components until the page
has finished loading, lazy loading reduces TTI and provides a more engaging user
experience. -->






<!-- lifting the stateup -->
<!-- redux -->
<!-- optimize the performance of our website -->
<!-- memoization -->
<!-- how to apply styles in react -->
<!-- normal css -->
<!-- tailwind css -->
<!-- materail ui -->
<!-- third party libraries -->
<!-- framer motion (animation) ,react icons , chart.js-->

<!-- how to deploy our application -->
